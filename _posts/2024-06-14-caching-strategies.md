---
layout: post
categories: [Django]
title: caching 적용하기(1) Memcached와 Redis 중의 선택
author: tngtied
date: 2024-06-14
---

100만건의 댓글 리스트를 조회하는 view를 최적화하는 와중에 ORM을 이용한 쿼리 최적화만으로는 한계를 느끼고, 캐싱을 도입하기로 결정했다.

# Django Cache Framework

[Django's cache framework](https://docs.djangoproject.com/en/5.0/topics/cache/#top)를 참고했을 때 장고의 캐시 프레임워크는 6개가 있다.

## Memcached

메모리 기반의 캐싱이다. 범용 분산 캐시 시스템으로 각 노드가 서로 다른 데이터를 관리하며, 새로운 노드를 추가하여 쉽게 확장할 수 있다. 또한, 다중 스레딩을 사용하므로 주어진 노드에서 여러 개의 CPU 코어를 사용하여 병렬 처리를 할 수 있으며 단일 코어보다 향상된 처리 능력을 보인다.
Django에서의 바인딩으로는 pylibmc 또는 pymemcache를 사용한다.

## Redis

Redis는 인 메모리 캐싱으로 기본적으로 단일 인스턴스에서 실행되며, 분산 캐싱을 위해 Redis Cluster을 적용할 수 있다. 이를 통해 여러 노드에 데이터를 분산 저장할 수 있으며 수평적으로 확장할 수 있다. Redis Cluster에서 각 노드는 서로 다른 데이터를 관리한다. 기본적으로 단일 스레드 아키텍쳐이나, I/O스레드의 멀티스레딩을 통해 성능 향상을 꾀할 수 있다.

### Redis vs Memcached

Redis와 Memcached에 대해서 알아보던 중, 이 둘 간의 유사점이 많아 차이점을 알고, 해당 차이점을 기반으로 결정하고 싶어졌다.

1. 데이터 구조

- Redis: 문자열, 해시, 리스트, 세트, 비트맵, 스트림 등의 다양한 복잡한 구조의 데이터를 저장/조작할 수 있다
- Memcached: 문자열 기반의 키-값 저장소로 설계되어 있다.

2. 영속성

- Redis는 RDB 스냅샷과 AOF(Append Only File)로그를 통해 메모리의 데이터를 디스크에 저장할 수 있다.
- Memcached는 영속성을 지원하지 않으며 서버가 재시작되거나 장애가 발생할 시 데이터가 모두 손실된다.

3. 데이터 분산 방식

- Redis는 기본적으로 데이터 분산을 지원하지 않으나 Redis Cluster를 사용해서 분산 저장할 수 있다. Redis의 데이터 샤딩은 Redis Cluster를 사용하여 이루어진다. 분산된 노드들은 마스터-슬레이브 모델을 사용하므로 한 노드에 장애가 발생하더라도 운영에 지장이 생기지 않는다. 예를 들어 A 노드에 장애가 발생한다면 A노드의 복제 노드인 A-1이 마스터 노드로 승격되고 대신 사용된다.
- Memcached는 기본적으로 분산 캐시로 설계되었다. 데이터 샤딩은 클라이언트 어플리케이션에 의해 이루어진다. 분산된 노드들은 서로 독립적으로, 한 노드에 장애가 발생할 시 그 노드의 데이터는 접근이 불가능해진다.

4. 트랜잭션 지원

- Redis는 트랜잭션을 지원한다. 복잡한 일련의 연산이 필요할 때 해당 연산들을 원자적으로 실행할 수 있다.
- Memcached는 연산의 원자성을 지원하기는 하지만 트랜잭션을 지원하지는 않는다.

#### 데이터 샤딩이란?

대규모 데이터베이스, 캐싱 시스템에서 데이터를 분할하고 분산 저장하는 기술으로, 데이터베이스에서 관리하는 데이터를 해시 함수나 범위 기준 등을 사용하여 샤드 단위로 분할하고, 각각 독립적인 데이터베이스나 노드에 저장하는 것을 의미한다. 데이터 파티셔닝과의 차이점은, 파티셔닝은 모든 데이터를 동일한 저장소에 저장하지만 샤딩은 여러 데이터베이스/노드에 저장한다는 것이다.

## Database Caching

데이터베이스를 캐시로 사용하는 전략이다. 인덱싱이 잘 되어있을수록 효과적으로 작동한다. 그러나 읽기/쓰기 성능의 저하, 관리 복잡성의 증가, 비용 증가, 데이터베이스의 부하 증가로 인해 캐시의 장점을 사용하지 못하게 되므로 고려하지 않기로 결정했다.

## Filesystem Caching

파일을 저장소로 하는 캐싱 전략이다. 디스크 접근 속도의 제한, 관리 복잡성의 증가, 스케일링의 문제가 있으므로 고려하지 않기로 결정했다.

# 선택

위에서 분석한 캐싱 전략들 중, 나는 Redis를 사용하기로 결정했다. 그 이유는 다음과 같다.

- Redis는 트랜잭션을 지원한다.

100만건의 게시물 리스트의 경우 그 중 게시물이 삭제되거나, 추가되는 등의 작업이 일어날 수 있다. 이 때 캐싱된 데이터에 대한 추가 연산이 필요한데, 복잡한 연산에 대한 트랜잭션을 지원하는 Redis는 매력적인 옵션이다.

- Redis는 List 자료형을 지원한다.

100만건의 게시물이란 결국 특정한 형식의 object의 list이므로, 해당 자료형을 지원한다는 점은 장점으로 다가온다.

- Redis는 Pub/Sub 메시징 시스템을 지원한다.

이후 해당 어플리케이션에 웹소켓을 이용한 실시간 통신을 구현해볼 계획이 있으므로 게시/구독 시스템은 유용하다.

이와 같은 이유들을 기반으로 나는 Redis를 도입하기로 결정하였으며, 다중 스레딩을 기반으로 운영되는 Django 서버에 대응하기 위해 Redis Cluster를 도입하기로 했다. Redis 도입기는 다음 게시물을 통해 서술하겠다.
